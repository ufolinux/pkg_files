From f4d789a6b93b477561b78a84e31dc49d04928681 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Jonas=20=C3=85dahl?= <jadahl@gmail.com>
Date: Mon, 24 Oct 2022 12:35:48 +0200
Subject: [PATCH 1/2] build: Don't warn about unused parameters

This makes the build pass without warnings.
---
 meson.build | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/meson.build b/meson.build
index 02e6c73..f17e2a8 100644
--- a/meson.build
+++ b/meson.build
@@ -15,6 +15,13 @@ cc = meson.get_compiler('c')
 sh = find_program('sh')
 xxd = find_program('xxd')
 
+all_warnings = [
+        '-Wno-unused-parameter',
+]
+
+supported_warnings = cc.get_supported_arguments(all_warnings)
+add_project_arguments(supported_warnings, language: 'c')
+
 dbus_dep = dependency('dbus-1')
 libcap_dep = dependency('libcap')
 libsystemd_dep = dependency('libsystemd', required: get_option('libsystemd'))

From b74092b1f1772f9b778749724468d595eaba6571 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Jonas=20=C3=85dahl?= <jadahl@gmail.com>
Date: Mon, 24 Oct 2022 12:36:16 +0200
Subject: [PATCH 2/2] daemon: Add support for
 org.freedesktop.DBus.Properties.GetAll

This makes GDBus proxies generated by gdbus-codegen able to fetch
properties.
---
 org.freedesktop.RealtimeKit1.xml |  4 ++
 rtkit-daemon.c                   | 91 ++++++++++++++++++++++++++++++++
 2 files changed, 95 insertions(+)

diff --git a/org.freedesktop.RealtimeKit1.xml b/org.freedesktop.RealtimeKit1.xml
index b8ad33c..6b9b3ae 100644
--- a/org.freedesktop.RealtimeKit1.xml
+++ b/org.freedesktop.RealtimeKit1.xml
@@ -35,6 +35,10 @@
                        <arg name="property" direction="in" type="s"/>
                        <arg name="value" direction="out" type="v"/>
                 </method>
+                <method name="GetAll">
+                       <arg name="interface" direction="in" type="s"/>
+		       <arg name="props" direction="out" type="a{sv}"/>
+                </method>
         </interface>
         <interface name="org.freedesktop.DBus.Introspectable">
                 <method name="Introspect">
diff --git a/rtkit-daemon.c b/rtkit-daemon.c
index 17122fa..da57192 100644
--- a/rtkit-daemon.c
+++ b/rtkit-daemon.c
@@ -88,6 +88,10 @@ static const char introspect_xml[] = {
 
 #define TIMESPEC_MSEC(ts) (((int64_t) (ts).tv_sec * 1000LL) + ((int64_t) (ts).tv_nsec / 1000000LL))
 
+#ifndef ARRAY_SIZE
+#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
+#endif
+
 /* If we actually execute a request we temporarily upgrade our realtime priority to this level */
 static unsigned our_realtime_priority = 21;
 
@@ -1256,6 +1260,70 @@ static int handle_dbus_prop_get(const char* property, DBusMessage *r) {
         return 0;
 }
 
+static int handle_dbus_prop_get_all(DBusMessage *r) {
+
+        DBusMessageIter iter, dict_iter;
+        struct {
+                const char *name;
+                int type;
+		const char *type_string;
+                void *value;
+        } props[] = {
+                {
+                        .name = "RTTimeUSecMax",
+                        .type = DBUS_TYPE_INT64,
+                        .type_string = DBUS_TYPE_INT64_AS_STRING,
+                        .value = &rttime_usec_max,
+                },
+                {
+                        .name = "MaxRealtimePriority",
+                        .type = DBUS_TYPE_INT32,
+                        .type_string = DBUS_TYPE_INT32_AS_STRING,
+                        .value = &max_realtime_priority,
+                },
+                {
+                        .name = "MinNiceLevel",
+                        .type = DBUS_TYPE_INT32,
+			.type_string = DBUS_TYPE_INT32_AS_STRING,
+                        .value = &min_nice_level,
+                }
+        };
+        size_t i;
+
+        dbus_message_iter_init_append(r, &iter);
+
+        assert_se(dbus_message_iter_open_container(&iter,
+                                                   DBUS_TYPE_ARRAY,
+                                                   DBUS_DICT_ENTRY_BEGIN_CHAR_AS_STRING
+                                                   DBUS_TYPE_STRING_AS_STRING
+                                                   DBUS_TYPE_VARIANT_AS_STRING
+                                                   DBUS_DICT_ENTRY_END_CHAR_AS_STRING,
+                                                   &dict_iter));
+
+        for (i = 0; i < ARRAY_SIZE(props); i++) {
+                DBusMessageIter dict_entry_iter, sub;
+
+                assert_se(dbus_message_iter_open_container(&dict_iter,
+                                                           DBUS_TYPE_DICT_ENTRY, NULL,
+                                                           &dict_entry_iter));
+                assert_se(dbus_message_iter_append_basic(&dict_entry_iter, DBUS_TYPE_STRING,
+                                                         &props[i].name));
+
+                assert_se(dbus_message_iter_open_container(&dict_entry_iter,
+							   DBUS_TYPE_VARIANT,
+							   props[i].type_string,
+							   &sub));
+                assert_se(dbus_message_iter_append_basic(&sub, props[i].type, props[i].value));
+                assert_se(dbus_message_iter_close_container(&dict_entry_iter, &sub));
+
+		assert_se(dbus_message_iter_close_container(&dict_iter, &dict_entry_iter));
+        }
+
+	assert_se(dbus_message_iter_close_container(&iter, &dict_iter));
+
+        return 0;
+}
+
 static DBusHandlerResult dbus_handler(DBusConnection *c, DBusMessage *m, void *userdata) {
         DBusError error;
         DBusMessage *r = NULL;
@@ -1421,6 +1489,29 @@ static DBusHandlerResult dbus_handler(DBusConnection *c, DBusMessage *m, void *u
                                 "Unknown interface %s",
                                 interface));
 
+        } else if (dbus_message_is_method_call(m, "org.freedesktop.DBus.Properties", "GetAll")) {
+                const char *interface;
+
+                if (!dbus_message_get_args(m, &error,
+                                           DBUS_TYPE_STRING, &interface,
+                                           DBUS_TYPE_INVALID)) {
+
+                        syslog(LOG_DEBUG, "Failed to parse property get call: %s\n", error.message);
+                        assert_se(r = dbus_message_new_error(m, error.name, error.message));
+                        goto finish;
+                }
+
+                if (strcmp(interface, "org.freedesktop.RealtimeKit1") == 0) {
+                        assert_se(r = dbus_message_new_method_return(m));
+
+                        handle_dbus_prop_get_all(r);
+                } else
+                        assert_se(r = dbus_message_new_error_printf(
+                                m,
+                                DBUS_ERROR_UNKNOWN_PROPERTY,
+                                "Unknown interface %s",
+                                interface));
+
         } else if (dbus_message_is_method_call(m, "org.freedesktop.DBus.Introspectable", "Introspect")) {
                 const char *xml = introspect_xml;
 
